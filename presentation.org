#    -*- mode: org -*-
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:1
#+REVEAL_MARGIN: 0.2
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: night
#+REVEAL_HLEVEL: 999
#+REVEAL_EXTRA_CSS: ./presentation.css

#+TITLE: Introduction to Datomic
#+AUTHOR: Daniel De Aguiar
#+EMAIL: ddeaguiar@gmail.com

* About Me
- Software Engineer/Consultant.
- Currently working with Clojure.
* What /is/ Datomic?
** Ledger

#+ATTR_REVEAL: :frag (appear)
#+BEGIN_QUOTE
The ledger is a permanent summary of all amounts entered in supporting
journals which list individual transactions by date.
- https://en.wikipedia.org/wiki/Ledger
#+END_QUOTE

#+BEGIN_NOTES
Ledgers have been used in bookkeeping for thousands of years.

Key points from the quote:
- /Permanent/ summary
- /List/ of individual transactions
- /by/ date
#+END_NOTES

** Git

#+BEGIN_NOTES
Our version control systems are purpose built for tracking change at various degrees of granularity.

We value tools like this and would (should) go up in arms if were told not to use them.
#+END_NOTES

** Datomic is a relational database

#+ATTR_REVEAL: :frag (appear)
It's an information system

#+ATTR_REVEAL: :frag (appear)
Information consists of /facts/

#+ATTR_REVEAL: :frag (appear)
Datomic accumulates facts

#+ATTR_REVEAL: :frag (appear)
It is not /Place Oriented/.

#+BEGIN_NOTES
The past is immutable.

New information /does not/ replace old, in place.
#+END_NOTES

** What are facts?
#+ATTR_REVEAL: :frag (appear)
- A fact is a statement about an entity.
- Facts are tuples.

#+BEGIN_NOTES
A fact relates an entity (subject) to a value through an attribute (predicate).
#+END_NOTES

** Fact tuples

/[Entity Attribute Value]/

#+BEGIN_NOTES
Structure of a Fact tuple
#+END_NOTES

** Fact example
#+ATTR_HTML: :width 100%
| Entity | Attribute | Value    |
|--------+-----------+----------|
| dan    | likes     | fishing  |

** Fact example
#+ATTR_HTML: :width 100%
| Entity | Attribute | Value          |
|--------+-----------+----------------|
| dan    | likes     | fishing        |
| dan    | likes     | fly fishing    |

#+BEGIN_NOTES
How are these changes represented given that Datomic accumulates facts?
The next slides revisit our fact tuple example in this context.
#+END_NOTES

** Fact tuples are 5-tuples
/[Entity Attribute Value Transaction Operation]/

#+BEGIN_NOTES
Transaction is a monotonically increasing value.

Operation represents either an /assertion/ or /retraction/.
#+END_NOTES

** Revisit our fact example
#+ATTR_HTML: :width 100%
| Entity | Attribute | Value          | Transaction | Operation |
|--------+-----------+----------------+-------------+-----------|
| dan    | likes     | fishing        |        1000 | true      |
| dan    | likes     | fishing        |        1210 | false     |
| dan    | likes     | fly fishing    |        1210 | true      |

** A Datomic database is a collection of fact tuples
*** Entity Example
#+BEGIN_SRC clojure
[{:name "Daniel" :likes "Fishing"}
{:name "Kolby" :likes "Gaming"}
{:name "Juan" :likes "Fishing"}]
#+END_SRC

#+BEGIN_NOTES
Take a map representation of an entity and convert it to a collection
of tuples. This collection is a simple database.
#+END_NOTES

*** Fact Database
#+BEGIN_SRC clojure
[["Daniel" :likes "Fishing"]
["Kolby" :likes "Gaming"]
["Juan" :likes "Fishing"]]
#+END_SRC

#+BEGIN_NOTES
This /database/ is an /immutable/ clojure value.
Datomic databases /are/ immutable and can be treated as values!
#+END_NOTES

** Datalog

We can query the database using Datomic Datalog.

#+ATTR_REVEAL: :frag (appear)
Datalog is a /declarative/ database query language

#+BEGIN_NOTES
Datalog has roots in logic programming.
#+END_NOTES

#+ATTR_REVEAL: :frag (appear)
Code sample

#+ATTR_REVEAL: :frag (appear)
http://www.learndatalogtoday.org/

* Datomic's architecture

- Peer(s)
- Client(s)
- Peer Server
- Transactor
- Storage

http://docs.datomic.com/architecture.html

#+BEGIN_NOTES
- Composition of simple services
- Leverage redundant, scalable storage systems (We are no longer constrained by space!)
- Separation of writes from reads
- Favors ACID transactions instead of write scalability
- Distributed index resides in the application server tier, localizing queries.
#+END_NOTES

** Peers
- Submit transactions
- Provide data access capabilities

#+BEGIN_NOTES
Embedded. JVM languages only.

Provides caching.

Reads from storage if necessary.
#+END_NOTES

** Clients
- Light-weight
- Submit transactions
- Provides data access capabilities

#+BEGIN_NOTES
Embedded. Any language.

Does not provide caching.

#+END_NOTES

** Peer Server
- Accepts queries/transactions from Clients.
- Submits transactions
- Provides data access

#+BEGIN_NOTES
JVM Process.

Provides caching.
#+END_NOTES

** Transactor
- Accepts transactions
- Processes transactions serially
- Writes to storage

#+BEGIN_NOTES
Provides Datomic's ACID guarantees.
#+END_NOTES

** Storage
- Interface to underlying storage
** Trade-offs
Favors ACID transactions instead of write scalability

#+BEGIN_NOTES
Not well suited for systems that favor unlimited write scalability.
#+END_NOTES
* Working with Datomic

** Datomic Indexes

| Desired read shape | Datomic supports via         |
|--------------------+------------------------------|
| k/v                | AVET                         |
| row                | EAVT                         |
| column             | AEVT                         |
| document           | EAVT, partitions, components |
| graph              | VAET                         |

From: /Why Datomic, Part 1/

(http://www.datomic.com/videos.html)

#+BEGIN_NOTES
Datomic's indexes support different ways of reading data.

This does not have to be an upfront design decision.
#+END_NOTES

** TBD
TODO: Demonstrate graph view (bidirectional reference traversal)

** TBD
#+BEGIN_SRC clojure
(require '[datomic.api :as d])

(def uri "datomic:mem//my-db")

(d/create-database uri)

(def conn (d/conn uri))
(def db (d/db conn))

(d/q '[:find ?e
       :where
       [?e :db/doc "some doc"]]
     db)
#+END_SRC
*** Datomic as an in-memory database
Take the entity we worked with earlier and create a Datomic schema for
it.
Demonstrate that schema is data and consisting of a collection of
facts.
Demonstrate transaction, retraction, querying
**** The database as a value
Discuss how, in all these cases, we're passing the database as a
value. Relate this back to Datomic's architecture (peers).

We can create a new database value by:
- Filtering
- Applying prospective (TODO: correct word?) changes.

These manipulations /do not/ change the data in the underlying data store.
*** Datomic + Scala
- Datomic provides Java APIs.
- Datomic is available in Clojars.

#+BEGIN_SRC scala
import datomic.api

val uri = "datomic:mem//my-db"
Peer.createDatabase(uri)
val conn = Peer.connect(uri)
val db = Peer.db(conn)

Peer.q("[:find ?e :where [?e :db/doc \"some doc\"]]")
#+END_SRC
**** Use the Docker Datomic environment for exploration
**** Use the music brains db
Show the schema
Walk through queries and transactions with Scala.
*** Wrapping up
The Datomic docs
The Datomic apis

I'm available for further inquiries. If you'd like to talk more about
Datomic and/or Clojure at your organization, let me know!

Hand out Datomic stickers if I can get them!!
